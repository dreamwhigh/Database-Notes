---
typora-copy-images-to: pics
---

# MySQL

[聚簇索引与非聚簇索引](<https://www.jianshu.com/p/fa8192853184>)

[《高性能MySQL》读后感——聚簇索引](<https://www.jianshu.com/p/74b2db536454>)

## 索引

### 什么是索引

索引是一种在**表的列上**创建的**数据结构** ，包含一个表中列的值，并且这些值存储在一个数据结构（最常见的是B-Tree）中。

### 为什么创建索引

索引用于**快速找出在某个列中有一特定值的行**，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，即**全表扫描**，表越大，查询数据所花费的时间就越多。如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。



数据在磁盘上是以块的形式存储的。为确保对磁盘操作的原子性，访问数据的时候会一并访问所有数据块。磁盘上的这些数据块与链表类似，即它们都包含一个数据段和一个指针，指针指向下一个节点（数据块）的内存地址，而且它们都不需要连续存储（即逻辑上相邻的数据块在物理上可以相隔很远）。

鉴于很多记录只能做到按一个字段排序，所以要查询某个未经排序的字段，就需要使用线性查找，即要访问N/2个数据块，其中N指的是一个表所涵盖的所有数据块。如果该字段是非键字段（也就是说，不包含唯一值），那么就要搜索整个表空间，即要访问全部N个数据块。（在某些情况下，索引可以避免排序操作。）

然而，对于经过排序的字段，可以使用二分查找，因此只要访问log2 N个数据块。同样，对于已经排过序的非键字段，只要找到更大的值，也就不用再搜索表中的其他数据块了。这样一来，性能就会有实质性的提升。

#### 适合创建索引

- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 查询中与其他表有关联的字段，例如外键关系
- 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）
- 查询中统计或者分组的字段

#### 不适合创建索引

- 数据唯一性差（一个字段的取值只有几种时）的字段
- 频繁更新的字段

- where条件里用不到的字段
- where 子句里对索引列使用不等于（<>）

#### 索引失效

- 如果条件中有or，即使其中有**部分条件带索引**也会使用(这也是为什么尽量少用or的原因)，除非**将or条件中的每个列都加上索引，索引才会生效**
- 对于多列索引，**不是使用的第一部分**，则不会使用索引
- like查询是以%开头（% 为通配符，默认字母；%k 表示以字母 "k" 结尾字符）
- 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
-  where 子句里对索引列上有数学运算，用不上索引
- where 子句里对有索引列使用函数，用不上索引
- mysql估计使用全表扫描要比使用索引快，则不使用索引

### 数据结构

二叉查找树：左子树的键值小于根的键值，右子树的键值大于根的键值。

平衡二叉树（AVL树）：在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。进行插入或删除节点，可能导致AVL树失去平衡，需要通过旋转使其恢复平衡。

#### 平衡多路查找树（B-Tree）



B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是**一个节点可以拥有多于2个子节点的二叉查找树**。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。



### 索引类型

- 唯一索引：不允许其中任何两行具有相同值的索引
- 主键索引：可以认为是特殊的唯一索引，仅利用主键建立的索引
- 单一索引：任何一个单一数据项（表中的某一列）建立的索引
- 复合索引：多个数据项（表中的多列）建立的索引
- 聚簇索引：利用主键建立的索引，其物理存放顺序与主键顺序一致。因为数据只有一个物理存放顺序，所以一个表只有一个聚簇索引。
- 非聚簇索引(二级索引，辅助索引)：除了聚簇索引之外，其余所有的索引都是非聚簇索引
- 覆盖索引：一个索引包含(覆盖)所要查询的字段的值，注意覆盖索引与具体的查询有关

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是**一种数据存储方式**。比如，InnoDB的聚簇索引使用B+Tree的数据结构存储索引和数据。

当表有聚簇索引时，它的**数据行实际上存放在索引的叶子页**(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**（不过，覆盖索引可以模拟多个聚簇索引的情况）。

下图为聚簇索引的数据分布，节点页只包含了索引列，叶子页包含行的全部数据，其中索引列包含的是整数值。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-b88c14d5b159a60b.webp)

下图为InnoDB（支持聚簇索引）的数据分布，每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回流指针以及所有的剩余列（在这个例子中是col2)。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。叶节点包含了完整的数据记录，这种索引即为**聚簇索引**。

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键（6 个字段长度的长整形隐含字段）**来作为聚簇索引。所以InnoDB要求表必须有主键（MyISAM可以没有），InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

```mysql
CREATE TABLE layout_test(
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
```

![img](E:\GitHub\Database-Notes\docs\pics\3190591-23648691d81134a4.webp)

InnoDB主键索引的分布，按照B+Tree搜索算法搜索索引，如果指定的Key存在，其对应的data 域（叶子节点）包含完整的数据记录。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-c059c85eaf693801.webp)

#### 非聚簇索引

对于非聚簇索引的存储引擎，**表数据存储顺序与索引顺序无关**，叶结点包含**索引字段值及指向数据页数据行的逻辑指针**，其行数量与数据表行数据量一致。

MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。MyISAM按照数据插入的顺序存储在磁盘上，左边为行号(row number)，从0开始。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-de55e5b8e4721453.webp)

MyISAM不支持聚簇索引，建立的primary key的索引结构图中**每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col1的顺序存储**。MyISAM是按列值与行号来组织索引的。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-c870bce84eef8f08.webp)

同样的，col2 的索引结构图中**每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col2的顺序存储**。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-3235799d9bff720e.webp)

MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-fd1159ba20285a23.webp)



#### 二级索引

聚簇索引（InnoDB）的二级索引叶子节点保存的不是指向行的物理位置的指针，而是**行的主键值**。

通过二级索引查找行，InnoDB的的二级索引的叶子节点存放的是**KEY字段加主键值**，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。对于 InnoDB，自适应哈希索引能够减少这样的重复工作。

非聚簇索引（MyISAM）的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是**数据的物理地址**。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-11cabdfdce46f976.webp)

聚簇索引：

- 主索引检索过程

  InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

- 辅助索引检索过程

  若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

非聚簇索引：

主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。

![img](E:\GitHub\Database-Notes\docs\pics\10154499-5244179cc19a1c21.webp)

![img](E:\GitHub\Database-Notes\docs\pics\10154499-5772dddedb909374.webp)

#### 按主键顺序插入行

对于聚簇索引的存储引擎，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

对于顺序的主键值，InnoDB 把每一条记录都存储在上一条记录的后面，达到页的最大填充因子时（InnoDB 默认最大填充因子为页的 15/16），下一条记录会写入新页。索引结构相对紧凑，磁盘碎片少，效率也高。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-341cb567b964f649.webp)

如果写入主键值是无序的，通常要在已有数据之间寻找合适的位置，并分配空间，不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入至少需要修改三个页面。而频繁的页分裂又会导致也变得稀疏，被不规则填充，最终数据会有碎片。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-429aa829eb39b79c.webp)

#### 聚簇索引的优势

1. **可以把相关数据保存在一起**

   例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

2. **数据访问更快**

   由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

3. 使用**覆盖索引扫描的查询可以直接使用叶节点中的主键值**

4. **InnoDB在移动行时无须更新辅助索引中的“指针"**

   辅助索引使用主键作为"指针"而不是使用地址值作为指针。即行的位置会随着数据库里数据的修改而发生变化（B+树节点分裂以及Page的分裂），聚簇索引可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。

#### 聚簇索引的劣势

1. **插入速度严重依赖插入顺序**

   按照主键的顺序插入是加载数据到 InnoDB 最快的方式，若不按主键顺序加载数据，在加载完成后最好使用 OPTIMIZE TABLE优化表。

2. **更新列的代价很高**

   强制将每个被更新的行移动到新的位置。

3. **页分裂问题，导致占用更多磁盘空间**

   插入新行或者主键被更新需要移动行时，会面临页分裂问题，存储引擎会在页面已满时将该页分裂成两个页面来容纳该行，会导致表占用更多的磁盘空间。

4. **二级索引需要两次索引**

5. **过长的主键值导致辅助索引变得更大**

   如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用更多的物理空间。

