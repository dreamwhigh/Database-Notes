---
typora-copy-images-to: pics
---

# MySQL

[聚簇索引与非聚簇索引](<https://www.jianshu.com/p/fa8192853184>)

[《高性能MySQL》读后感——聚簇索引](<https://www.jianshu.com/p/74b2db536454>)

## 索引

### 什么是索引

索引是一种在**表的列上**创建的**数据结构** ，包含一个表中列的值，并且这些值存储在一个数据结构（最常见的是B-Tree）中。

### 为什么创建索引

索引用于**快速找出在某个列中有一特定值的行**，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，即**全表扫描**，表越大，查询数据所花费的时间就越多。如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。



数据在磁盘上是以块的形式存储的。为确保对磁盘操作的原子性，访问数据的时候会一并访问所有数据块。磁盘上的这些数据块与链表类似，即它们都包含一个数据段和一个指针，指针指向下一个节点（数据块）的内存地址，而且它们都不需要连续存储（即逻辑上相邻的数据块在物理上可以相隔很远）。

鉴于很多记录只能做到按一个字段排序，所以要查询某个未经排序的字段，就需要使用线性查找，即要访问N/2个数据块，其中N指的是一个表所涵盖的所有数据块。如果该字段是非键字段（也就是说，不包含唯一值），那么就要搜索整个表空间，即要访问全部N个数据块。（在某些情况下，索引可以避免排序操作。）

然而，对于经过排序的字段，可以使用二分查找，因此只要访问log2 N个数据块。同样，对于已经排过序的非键字段，只要找到更大的值，也就不用再搜索表中的其他数据块了。这样一来，性能就会有实质性的提升。

### 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

#### 适合创建索引

- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 查询中与其他表有关联的字段，例如外键关系
- 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找）
- 查询中统计或者分组的字段

#### 不适合创建索引

- 数据唯一性差（一个字段的取值只有几种时）的字段
- 频繁更新的字段

- where条件里用不到的字段
- where 子句里对索引列使用不等于（<>）

#### 索引失效

- 如果条件中有or，即使其中有**部分条件带索引**也会使用(这也是为什么尽量少用or的原因)，除非**将or条件中的每个列都加上索引，索引才会生效**
- 对于多列索引，**不是使用的第一部分**，则不会使用索引
- 前导模糊查询不能利用索引，例如like查询是以%开头（% 为通配符）
- 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
-  where 子句里对索引列上有数学运算，用不上索引
- where 子句里对有索引列使用函数，用不上索引
- mysql估计使用全表扫描要比使用索引快，则不使用索引，例如表太小的时候

### 数据结构

二叉查找树：左子树的键值小于根的键值，右子树的键值大于根的键值。

平衡二叉树（AVL树）：在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。进行插入或删除节点，可能导致AVL树失去平衡，需要通过旋转使其恢复平衡。

[什么是B-Tree](<https://www.cnblogs.com/dongguacai/p/7239599.html>)

[数据库常见索引解析](<https://blog.csdn.net/wl044090432/article/details/53423333>)

#### 磁盘IO与预读

磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘IO的时间，大概9ms左右。这个成本是访问内存的十万倍左右；正是由于磁盘IO是非常昂贵的操作，所以计算机操作系统对此做了优化：预读；每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。因为局部预读原理说明：当访问一个地址数据的时候，与其相邻的数据很快也会被访问到。每次磁盘IO读取的数据我们称之为一页（page）。一页的大小与操作系统有关，一般为4k或者8k。这也就意味着读取一页内数据的时候，实际上发生了一次磁盘IO。

#### B-Tree与二叉查找树

实现索引是使用B-Tree而不是二叉查找树，关键因素是**磁盘IO的次数**。

##### 二叉查找树

对于一个树高为4的二叉树，查找值10位于叶子节点上，那么磁盘IO的次数是4，即**磁盘IO的次数由树的高度来决定。**

![img](E:\GitHub\Database-Notes\docs\pics\20161201164339243.jpg)

**减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以诞生了B-Tree。**

##### 平衡多路查找树（B-Tree）

B树是**一个节点可以拥有多于2个子节点的二叉查找树**。它能够存储数据、对其进行排序并允许以O(log N)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。（N为关键字总数）

m阶的B树具有如下特征：

1.根结点至少有两个子女。

2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

4.所有的叶子结点都位于同一层。

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子为空，或已经是叶子结点。

**由于树的高度减小，且同一个结点内的关键字比对是在内存中完成中，不涉及到磁盘IO，所以B-Tree的磁盘IO次数更少，性能更好。**

![img](E:\GitHub\Database-Notes\docs\pics\20161201164718353.jpg)

#### B+ Tree

一个m阶的B+树具有如下几个特征：

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

 B+树是B-树的变体，也是一种多路搜索树，与B-Tree存在以下几点不同：

1. 非叶子节点只存储键值信息，只有叶子节点含有键值信息和指向真实记录的指针；B-Tree中中间结点和叶子节点都含有指向真实记录的指针
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中，即所有关键字都在叶子结点出现（非叶子结点和叶子结点的字段值会重复，而B-Tree 不会重复）
4. 不可能在非叶子结点命中；B-Tree也可能在非叶子结点命中![img](E:\GitHub\Database-Notes\docs\pics\20161201164907855.jpg)

##### B+树的优势：

1. b+树的中间节点不保存数据，所以中间节点（磁盘页）能容纳更多节点元素，树变得更”矮胖“，使得查询的IO次数更少；

2. b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；

3. 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。

##### 与红黑树相比

[CS-Notes MySQL](<https://cyc2018.github.io/CS-Notes/#/notes/MySQL?id=_3-%e4%b8%8e%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e6%af%94%e8%be%83>)

（一）更少的查找次数

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

### 索引类型

- 唯一索引：不允许其中任何两行具有相同值的索引
- 主键索引：可以认为是特殊的唯一索引，仅利用主键建立的索引
- 单一索引：任何一个单一数据项（表中的某一列）建立的索引
- 复合索引：多个数据项（表中的多列）建立的索引
- 聚簇索引：利用主键建立的索引，其物理存放顺序与主键顺序一致。因为数据只有一个物理存放顺序，所以一个表只有一个聚簇索引。
- 非聚簇索引(二级索引，辅助索引)：除了聚簇索引之外，其余所有的索引都是非聚簇索引
- 覆盖索引：一个索引包含(覆盖)所要查询的字段的值，注意覆盖索引与具体的查询有关

#### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是**一种数据存储方式**。比如，InnoDB的聚簇索引使用B+Tree的数据结构存储索引和数据。

当表有聚簇索引时，它的**数据行实际上存放在索引的叶子页**(leaf page)中。因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**（不过，覆盖索引可以模拟多个聚簇索引的情况）。

下图为聚簇索引的数据分布，节点页只包含了索引列，叶子页包含行的全部数据，其中索引列包含的是整数值。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-b88c14d5b159a60b.webp)

下图为InnoDB（支持聚簇索引）的数据分布，每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回流指针以及所有的剩余列（在这个例子中是col2)。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。叶节点包含了完整的数据记录，这种索引即为**聚簇索引**。

**聚簇索引默认是主键**，如果表中没有定义主键，InnoDB 会选择一个**唯一的非空索引**代替。如果没有这样的索引，InnoDB 会**隐式定义一个主键（6 个字段长度的长整形隐含字段）**来作为聚簇索引。所以InnoDB要求表必须有主键（MyISAM可以没有），InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

```mysql
CREATE TABLE layout_test(
	col1 int NOT NULL,
	col2 int NOT NULL,
	PRIMARY KEY(col1),
	KEY(col2)
);
```

![img](E:\GitHub\Database-Notes\docs\pics\3190591-23648691d81134a4.webp)

InnoDB主键索引的分布，按照B+Tree搜索算法搜索索引，如果指定的Key存在，其对应的data 域（叶子节点）包含完整的数据记录。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-c059c85eaf693801.webp)

#### 非聚簇索引

对于非聚簇索引的存储引擎，**表数据存储顺序与索引顺序无关**，叶结点包含**索引字段值及指向数据页数据行的逻辑指针**，其行数量与数据表行数据量一致。

MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。MyISAM按照数据插入的顺序存储在磁盘上，左边为行号(row number)，从0开始。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-de55e5b8e4721453.webp)

MyISAM不支持聚簇索引，建立的primary key的索引结构图中**每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col1的顺序存储**。MyISAM是按列值与行号来组织索引的。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-c870bce84eef8f08.webp)

同样的，col2 的索引结构图中**每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col2的顺序存储**。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-3235799d9bff720e.webp)

MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-fd1159ba20285a23.webp)



#### 二级索引

聚簇索引（InnoDB）的二级索引叶子节点保存的不是指向行的物理位置的指针，而是**行的主键值**。

通过二级索引查找行，InnoDB的的二级索引的叶子节点存放的是**KEY字段加主键值**，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。对于 InnoDB，自适应哈希索引能够减少这样的重复工作。

非聚簇索引（MyISAM）的二级索引叶子节点存放的还是列值与行号的组合，叶子节点中保存的是**数据的物理地址**。所以可以看出MYISAM的主键索引和二级索引没有任何区别，主键索引仅仅只是一个叫做PRIMARY的唯一、非空的索引，且MYISAM引擎中可以不设主键。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-11cabdfdce46f976.webp)

聚簇索引：

- 主索引检索过程

  InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

- 辅助索引检索过程

  若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

非聚簇索引：

主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。

![img](E:\GitHub\Database-Notes\docs\pics\10154499-5244179cc19a1c21.webp)

![img](E:\GitHub\Database-Notes\docs\pics\10154499-5772dddedb909374.webp)

#### 按主键顺序插入行

对于聚簇索引的存储引擎，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。

对于顺序的主键值，InnoDB 把每一条记录都存储在上一条记录的后面，达到页的最大填充因子时（InnoDB 默认最大填充因子为页的 15/16），下一条记录会写入新页。索引结构相对紧凑，磁盘碎片少，效率也高。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-341cb567b964f649.webp)

如果写入主键值是无序的，通常要在已有数据之间寻找合适的位置，并分配空间，不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入至少需要修改三个页面。而频繁的页分裂又会导致也变得稀疏，被不规则填充，最终数据会有碎片。

![img](E:\GitHub\Database-Notes\docs\pics\3190591-429aa829eb39b79c.webp)

#### 聚簇索引的优势

1. **可以把相关数据保存在一起**

   例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

2. **数据访问更快**

   由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

3. 使用**覆盖索引扫描的查询可以直接使用叶节点中的主键值**

4. **InnoDB在移动行时无须更新辅助索引中的“指针"**

   辅助索引使用主键作为"指针"而不是使用地址值作为指针。即行的位置会随着数据库里数据的修改而发生变化（B+树节点分裂以及Page的分裂），聚簇索引可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。

#### 聚簇索引的劣势

1. **插入速度严重依赖插入顺序**

   按照主键的顺序插入是加载数据到 InnoDB 最快的方式，若不按主键顺序加载数据，在加载完成后最好使用 OPTIMIZE TABLE优化表。

2. **更新列的代价很高**

   强制将每个被更新的行移动到新的位置。

3. **页分裂问题，导致占用更多磁盘空间**

   插入新行或者主键被更新需要移动行时，会面临页分裂问题，存储引擎会在页面已满时将该页分裂成两个页面来容纳该行，会导致表占用更多的磁盘空间。

4. **二级索引需要两次索引**

5. **过长的主键值导致辅助索引变得更大**

   如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用更多的物理空间。

#### 哈希索引

[哈希索引](https://blog.csdn.net/olizxq/article/details/82313489)

哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

对于hash相同的，采用链表的方式解决冲突。类似于hashmap。因为索引的结构是十分紧凑的，所以hash索引的查询很快。

![img](E:\GitHub\Database-Notes\docs\pics\20180902103803602.png)

索引过程：

1. 计算索引字段对应的哈希值；
2. 使用该值在哈希表中查找对应的记录指针，时间复杂度 O（1）；
3. 比较指针所指向行的内容是否是索引字段，以确保索引的正确性。

**限制**

- 存储的是哈希值和指针，不存储字段值
- 数据不按照索引值顺序存储的，**不能用于排序**。
- **不支持部分索引列匹配查找**，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
- **支持等值比较查询**，包括=、IN()、<>（注意<>和<=>是不同的操作）。**不支持范围查询**，例如WHERE price>100。
- **不适用于哈希冲突多的情况**，如果哈希冲突很多时，需要进行链表的遍历操作，对链表中所有的行指针指向内容进行比较，**索引速度慢，并且索引维护操作的代价高**。

**自适应哈希索引**

在InnoDB 存储引擎中，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本（只能在类型为CHAR、VARCHAR或者TEXT的字段上创建全文索引）中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

```mysql
SELECT * FROM article WHERE MATCH(col1,col2) AGAINST('查询字符串')
```

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

**缺点**：加上新建索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个较大的数据创建索引也是一个很慢的过程。

**优点**：顺序扫描是每次都要扫描，而全文索引可一次索引，多次使用；检索速度快

**倒排索引**是实现“**单词-文档矩阵**”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。

![img](E:\GitHub\Database-Notes\docs\pics\524341-20160410174915968-1895730713.jpg)

#### 空间数据索引

空间索引是对存储在介质上的数据位置信息的描述

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

## 索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

组合索引（多列索引）的原则：

最左前缀：顾名思义，就是最左优先，要根据业务需求，where子句中使用最频繁的一列放在最左边

平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引（多列索引）。

```mysql
ALTER TABLE people ADD INDEX height_name_age (height,name,age);
//相当于创建了(height)单列索引，(height,name)组合索引以及(height,name,age)组合索引
```

### 索引列的顺序

让选择性最强的索引列放在前面。

**索引的选择性**：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

```mysql
SELECT COUNT(DISTINCT col1)/COUNT(*) AS col1_selectivity FROM table1;
```

### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

### 覆盖索引

索引包含所有需要查询的字段的值。

覆盖索引必须**要存储索引的列**，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。

当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到**“Using index”**的信息

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。

- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。

- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

### 小结

| 描述         | 特点                                                     | 使用场景                                           |                                                             |
| ------------ | -------------------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------- |
| B+ Tree索引  | 使用B+ Tree作为底层实现                                  | 对树进行搜索，查找速度快分为聚簇索引和非聚簇索引   | 查找、排序、分组                                            |
| 哈希索引     | 使用哈希作为底层实现                                     | 无法用于排序与分组只支持精确查找，时间复杂度为O(1) | 当索引值使用的频繁时，会在B+ Tree索引之上再创建一个哈希索引 |
| 全文索引     | 全文索引使用倒排索引实现，记录着关键词到其所在文档的映射 |                                                    | 查找文本中的关键词                                          |
| 空间数据索引 |                                                          | 从所有维度来索引数据                               | 用于地理数据存储                                            |

## 查询性能优化

### 使用 Explain 进行分析

[explain 详解](<https://www.cnblogs.com/gomysql/p/3720123.html>)

SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

返回字段的解释：

- id: 查询的序列号，表示查询中执行select子句或操作表的顺序，id相同，视为同一组，从上向下顺序执行；id值越大，优先级越高，越先执行

- select_type: 查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询

  - SIMPLE：查询中不包含子查询或者UNION
  - 查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY
  - 在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY

- table: 输出的行所引用的表

- type: 访问类型

  - ALL: 扫描全表
  - index: 扫描全部索引树
  - range: 扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、<、>等的查询
  - ref: 使用非唯一索引或非唯一索引前缀进行的查找
  - （eq_ref和const的区别：）
  - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
  - const, system: 单表中最多有一个匹配行，查询起来非常迅速，例如根据主键或唯一索引查询。system是const类型的特例，当查询- 的表只有一行的情况下， 使用system。
  - NULL: 不用访问表或者索引，直接就能得到结果，如select 1 from test where 1

- key: 显示MySQL实际决定使用的索引。如果没有索引被选择，是NULL

- key_len: 使用到索引字段的长度
  注：key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。

- ref: 显示哪个字段或常数与key一起被使用

- rows: 这个数表示mysql要遍历多少数据才能找到，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数，在innodb上可能是不准确的

- Extra: 执行情况的说明和描述。

  [执行计划 Extra](<https://www.cnblogs.com/wy123/p/7366486.html>)

  - using index ：使用覆盖索引的时候就会出现
  - using where：
  - using index condition：
  - using index & using where：
  - Using temporary
    表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询

### 最左匹配原则

[最左匹配原则](<https://blog.csdn.net/u013164931/article/details/82386555>)

```mysql
create table test(
a int ,
b int,
c int,
d int,
key index_abc(a,b,c)
)engine=InnoDB default charset=utf8;
```

对于联合索引 `index_abc(a,b,c)`，在查询中能够用到的索引是

- a
- a, b
- a, b, c

```mysql
explain select * from test where a<10 ;
explain select * from test where a<10 and b <10;
explain select * from test where a<10 and b <10 and c<10;
```

如果a, b, c 出现的顺序调换一下

```mysql
explain select * from test where b<10 and a <10;
explain select * from test where b<10 and a <10 and c<10;
```

mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。

```mysql
explain select * from test where b<10 and c <10;
explain select * from test where a<10 and c <10;
```

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。


### 优化数据访问

1. #### 减少请求的数据量

只返回必要的列：最好不要使用 SELECT * 语句。

只返回必要的行：使用 LIMIT 语句来限制返回的数据。

缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

2. #### 减少服务器端扫描的行数

最有效的方式是使用索引来覆盖查询。

### 重构查询方式

1. ### 切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

2. ### 分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

## 存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

|            | InnoDB                           | MyISAM               |
| ---------- | -------------------------------- | -------------------- |
| MySQL 默认 | 是                               | 否                   |
| 隔离级别   | 四个隔离级别                     |                      |
| 事务       | 支持（可使用 Commit / Rollback） | 不支持               |
| 锁         | 行级/表级                        | 表级                 |
| 外键       | 支持                             | 不支持               |
| 备份       | 在线热备份                       |                      |
| 崩溃恢复   |                                  | 概率高，恢复慢       |
| 特性       |                                  | 压缩表和空间数据索引 |
| 使用场景   |                                  | 读写分离的读表       |

### 四种 MySQL存储引擎

| **功 能**    | **MYISAM** | **Memory** | **InnoDB** | **Archive** |
| ------------ | ---------- | ---------- | ---------- | ----------- |
| 存储限制     | 256TB      | RAM        | 64TB       | None        |
| 支持事物     | No         | No         | Yes        | No          |
| 支持全文索引 | Yes        | No         | No         | No          |
| 支持数索引   | Yes        | Yes        | Yes        | No          |
| 支持哈希索引 | No         | Yes        | No         | No          |
| 支持数据缓存 | No         | N/A        | Yes        | No          |
| 支持外键     | No         | No         | Yes        | No          |

## 数据类型

## 数据类型

[MySQL 数据类型 ](<https://www.runoob.com/MySQL/MySQL-data-types.HTML>)

### 数值类型

**整型**

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。

**浮点型**

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

| 类型           | 大小                                          | 范围（有符号）                                               | 范围（无符号）                                               |
| :------------- | :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| TINYINT        | 1 字节                                        | (-2^7^，2^7^ - 1                                             | (0，2^8^ - 1)                                                |
| SMALLINT       | 2 字节                                        | (-2^15^，2^15^ - 1)                                          | (0，2^16^ - 1)                                               |
| MEDIUMINT      | 3 字节                                        | (-2^23^，2^23^ - 1)                                          | (0，2^24^ - 1)                                               |
| INT 或 INTEGER | 4 字节                                        | (-2^31^，2^31^ - 1)                                          | (0，2^32^ - 1)                                               |
| BIGINT         | 8 字节                                        | (-2^63^，2^63^ - 1)                                          | (0，2^64^ - 1)                                               |
| FLOAT[(M, D)]  | 4 字节                                        | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |
| DOUBLE[(M, D)] | 8 字节                                        | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |
| DECIMAL        | 对 DECIMAL(M,D) ，如果 M>D，为 M+2 否则为 D+2 | 依赖于 M 和 D 的值                                           | 依赖于 M 和 D 的值                                           |

其中 M 指数字总位数，D 指小数点后的位数

### 字符串类型

主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。

| 类型       | 大小               | 用途                            |
| :--------- | :----------------- | :------------------------------ |
| CHAR       | 0 - 2^8^ -1 字节   | 定长字符串                      |
| VARCHAR    | 0 - 2^16^ -1 字节  | 变长字符串                      |
| TINYBLOB   | 0 - 2^8^ - 1 字节  | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0 - 2^8^ - 1 字节  | 短文本字符串                    |
| BLOB       | 0 - 2^16^ - 1 字节 | 二进制形式的长文本数据          |
| TEXT       | 0 - 2^16^ - 1 字节 | 长文本数据（65 K）              |
| MEDIUMBLOB | 0 - 2^24^ - 1 字节 | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0 - 2^24^ - 1 字节 | 中等长度文本数据                |
| LONGBLOB   | 0 - 2^32^ - 1 字节 | 二进制形式的极大文本数据        |
| LONGTEXT   | 0 - 2^32^ - 1 字节 | 极大文本数据                    |

1GB=2^10^ MB=2^10^ * 2^10^ KB = 2^10^  * 2^10^  * 2^10^ byte =  2^10^  * 2^10^  * 2^10^  * 8 bit

### 日期和时间类型

### 

|           |        |            |                        |
| --------- | ------ | ---------- | ---------------------- |
| DATATIME  | 8 字节 | 与时区无关 |                        |
| TIMESTAMP | 4 字节 | 时区相关   | 首选，因为空间效率更高 |

| 类型      | 大小 (字节) | 范围                                                         | 格式                        | 用途                     |
| :-------- | :---------- | :----------------------------------------------------------- | :-------------------------- | :----------------------- |
| DATE      | 3           | 1000 - 01 - 01 - 9999 - 12 - 31                              | YYYY - MM - DD              | 日期值                   |
| TIME      | 3           | -838 : 59 : 59 - 838 : 59 : 59                               | HH : MM : SS                | 时间值或持续时间         |
| YEAR      | 1           | 1901- 2155                                                   | YYYY                        | 年份值                   |
| DATETIME  | 8           | 1000 - 01 - 01 00 : 00 : 00 - 9999 - 12 - 31 23 : 59 : 59    | YYYY - MM - DD HH : MM : SS | 混合日期和时间值         |
| TIMESTAMP | 4           | 1970 - 01 - 01 00 : 00 : 01 UTC - 2038 - 01 - 19 03 : 14 : 07  UTC | YYYYMMDD HHMMSS             | 混合日期和时间值，时间戳 |

### 其他数据类型

BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection 等



## 切分





## 主从复制

主要涉及三个线程（**binlog线程、I/O线程、SQL线程**），目的是实现**读写分离**

mysql主从复制用途

- 实时灾备，用于故障切换
- 读写分离，提供查询服务
- 备份，避免影响业务

 

主从部署必要条件：

- 主库开启binlog日志（设置log-bin参数）
- 主从server-id不同
- 从库服务器能连通主库